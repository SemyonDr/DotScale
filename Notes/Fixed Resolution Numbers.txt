------------------------
FIXED RESOLUTION
FRACTIONAL NUMBERS
REPRESENTATION
------------------------

To represent non-negative fractional numbers I use unsigned integers where lower 16 bit are dedicated for representing fractional part.
Upper 16 bit (or 48 bit for 64 bit number) represent integer part.
Integer part should be in range [0..65535].
Fractional part value is distributed uniformly with steps 1/65536 which is more than enough resolution for practical purposes of image processing.
This representation guarantees uniform precision and values representation in practical ranges, while `double` might introduce non-uniform distribution and unpredictable aliasing.

16 bit uint can be promoted to fixres with 16 bit left binary shift.


=== SCHEME ===

32 bit uint
  [ Integer 0..65535].[Fraction 0..65535]
31 xxxxxxxx xxxxxxxx . xxxxxxxx xxxxxxxx 0

Dot in the middle is imaginary in representation. Therefore math operations should take into account that stored value is 2^16 times larger than the value it represents.

Stored Binary Value = Actual Binary Value * 2^16



=== ADDITION ===
Addition is simple.

--- Fractional + Fractional ---
Numbers can be added directly.
fixres+fixres = fixres

--- Fractional + Integer ---
uint should be made fractional by multiplying it by 2^16.

(uint16 << 16) + fixres = fixres



=== MULTIPLICATION ===

--- Fractional x Fractional ---

Because both representations are multiplied by 2^16 in relation to actual numbers result should be divided by 2^16 once. 
Because values of representations are quite large there will be an overflow of 32 bit when they are multiplied. So, multiplication result should be stored in 64 bit number.

uint64_t temp = static_cast<uint64_t>(fixres) * static_cast<uint64_t>(fixres);
uint32_t res = static_cast<uint32_t>(temp >> 16);

--- Fractional x Integer ---

There is no need to transform integer to fractional and there is no need to divide by 2^16 because of that.
Multiplication result can fit into 32bit value, but overflow should be considered.



=== DIVISION ===

--- Fractional / Fractional ---

To preserve accuracy divided number should be enlarged as much as possible by multiplying by 2^32 and stored in uint64_t. 
Division operation returns only integer part. It should be multiplied by 2^16 to become fractional representation.
But because we multiplyed by 2^32 we should divide back by 2^32.
In total we should divide result by 2^16.

uint32_t divided, divisor; //Fixres
uint64_t temp = (static_cast<uint64_t>(divided) << 32) / static_cast<uint64_t>(divisor);
uint32_t res = static_cast<uint32_t>(temp >> 16);

--- Integer(16) / Fractional -> Fractional ---

Integer is enlarged as much as possible by multiplying by 2^48.
We divide i*2^48 / f*2^16 = (i/f)*2^32 and get integer result that is shifted by 32. We need shift to be only 16, so we divide by 2^16.

uint64_t temp = (static_cast<uint64_t>(integer) << 48) / static_cast<uint64_t>(fractional);
uint32_t res = static_cast<uint32_t>(temp >> 16);

--- Integer(32) / Fractional -> Integer(32) ---

Integer is enlarged as much as possible by multiplying by 2^32.
We divide i*2^32 / f*2^16 = (i/f)*2^16 and get integer result that is shifted right by 16. Therefore we shift left by 16 to get 32 bit integer.

uint64_t temp = (static_cast<uint64_t>(integer) << 32) / static_cast<uint64_t>(fractional);
uint32_t res = static_cast<uint32_t>(temp >> 16);

Note: for downscaler when we compute average the result can fit into 16 bit uint because divided integer value is accumulated from Area number of values each of which does fit into 16bit.

--- Fractional / Integer(16) ---

Fractional is multiplied for precision by 2^32 and then divided by the same amount.

uint64_t temp = (static_cast<uint64_t>(fractional) << 32) / static_cast<uint64_t>(integer);
uint32_t res = static_cast<uint32_t>(temp >> 32);

--- Integer(16) / Integer(16) -> Fractional ---

Divided integer is multiplied for precision by 2^16 and in the output you get fixres number.
Multiplying more than by 2^16 will not increase precision, so values can be kept in 32 bit range.

uint32_t res = (static_cast<uint32_t>(divided) << 16) / static_cast<uint32_t>(divisor);

